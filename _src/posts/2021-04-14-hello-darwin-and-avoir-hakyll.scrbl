#lang scribble/manual

Title: Hello Darwin and Avoir Hakyll
Date: 2021-04-14T11:04:09
Tags: raisin,haskell,racket,programming
Authors: Britt Anderson

I have moved this blog from @hyperlink["https://jaspervdj.be/hakyll/" "Hakyll"] to @hyperlink["https://github.com/pmatos/darwin" "Darwin"]. Here I describe some of what motivated the move.

<!-- more -->

@section[#:style 'unnumbered]{Why not Hakyll?}

First, I like hakyll and I really like @hyperlink["https://en.wikipedia.org/wiki/Haskell_%28programming_language%29" "Haskell"], but the relation is very asymmetric. I give and give some more, but Haskell is never happy. And despite its slogan, Haskell is a @hyperlink["https://arifordsham.com/haskell-doomed-to-succeed/" "victim of its own success"]. You cannot be a casual user of Haskell. You can be a tutorial user that works through exercises in @hyperlink["https://docs.haskellstack.org/en/stable/ghci/" "ghci"]. Or you can be a power user, but you cannot be a mid-level user. At least not for long. The reason is that someone will upgrade ghc, or cabal will change its installation defaults (and that was a great change by the way) or @hyperlink["https://github.com/commercialhaskell/stack/issues" "stack will fail"] to build something it used to, or everyone moves to nix and so now you have to @hyperlink["https://elland.me/posts/2021-03-26-haskell-docker-nix.html" "learn nix to use haskell"]. Then, despite all that, you can lose a day (or more) trying and failing to install something like @hyperlink["https://github.com/ghcjs/ghcjs/issues" "ghcjs"]. That was for me the last straw. Time to move on. 

Like a lot of laboratories in the time of Covid we are trying to move studies on line. I have some brilliant students who have jumped into the world of javascript and made everything just work. But I find javascript aesthetically distasteful. When I try to use it I feel like I am crushing a piece of aluminum foil between two fillings. If I have to learn yet another programming language to be productive, I don't want it to be javascript. And with the dream of @hyperlink["https://webassembly.org/" "web-assembly"] always on the horizon, I am especially reluctant to inflict such pain on myself for only a temporary gain. Thus, I wanted to see what I could use that might be more pleasant, and educational. I tried and failed with both @hyperlink["https://www.purescript.org/" "purescript"] and haskell.

Purescript is a very nice language. I recommend it, but again not for the casual user; not for the non-cs/software engineer. It is growing. It's @hyperlink["https://github.com/purescript/spago" "package manager changes"]. Installation is changing. You can use npm, but you can also use cabal - or at least I managed to. But everything is under development and one of the favorite educational tools is @hyperlink["https://github.com/JordanMartinez/purescript-jordans-reference" "losing its active development"], and so the beginner has a hard time unless they are in an environment where there are local experts.

Haskell can compile to javascript, but wait. The two most interesting modern tools are @hyperlink["https://haskell-miso.org/" "miso"] and @hyperlink["https://reflex-frp.org/" "reflex"], both of which rely on ghcjs. GHCJS lags behind ghc, and cannot, currently, be installed the same way. Both of these packages recommend nix. Well I tried, and the instructions failed. And not having a local expert, and requests for comments on Reddit unanswered, I felt compelled to move on. Too much time has been spent chasing a dream. I never actually got to really explore the dream either, because I was always too busy either combating cabal hell, trying to learn stack, trying to get the cabal-new commands to work, trying to puzzle out nix (or maybe even nixos, I tried that too). I will amplify on the nature of the dream below, but for now let it be said that the purpose of hakyll was to give me a chance to play within the haskell garden in a low risk fashion: learn some haskell; examine some of the abstractions; and do so in a way that I could pick it up and put it down as time demands for other projects. However, picking-up and putting-down cycles don't work in haskell. The development cycle is too fast. There is always a new tool or a new @hyperlink["https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/pragmas.html" "pragma"], and the people developing them are not writing the documentation at the @hyperlink["http://learnyouahaskell.com/" "learn you a haskell level"] (a very nice beginner's book by the way). Even worse is that the internet is not self-cleansing, and all the old, now wrong, documentation for how to do something is still there. I think @hyperlink["https://en.wikipedia.org/wiki/Lazy_evaluation" "lazy evaluation"] is awesome, I think lazy evaluation might capture aspects of human cognition. I also think the tight relationship between haskell code and the @hyperlink["https://plato.stanford.edu/entries/category-theory/" "category theory"] vocabulary, @hyperlink["https://plato.stanford.edu/entries/lambda-calculus/" " and lambda calculus"] origins might make haskell the preferred language for  implementing computational cognitive models where the code itself transparently documents the model's mathematical structure. But not if you are not in a position to use it daily, and to have around a group of users that also are using it daily. So, for now, I am setting haskell aside, though I will come back to it, and I am looking elsewhere for a tool that offers some of the same expressiveness, but with a lower bar to entry and casual exploration. I think I may have found it in racket.

@section[#:style 'unnumbered]{Why Darwin?}

Darwin is a fork of the Frog static site generator written in Racket. The answer to "why darwin" is really the same as for using hakyll: I have decided to learn some racket and I am using darwin as a mechanism to do so. And let me say it has been a pleasure. I cannot emphasize enough the difference in the experience. Racket has a nice @hyperlink["https://docs.racket-lang.org/" "updated documentation"] site. They have a much smaller user base that clusters around a few principal sources of interaction for questions and answers. As a language with a big focus on education they cater to the new user, and the user with limited time or knowledge.

I have not had to leave that much behind. Racket does give you modern features if you want them. You want @hyperlink["https://docs.racket-lang.org/lazy/index.html?q=lazy" "laziness"], you can get it. You want @hyperlink["https://docs.racket-lang.org/ts-guide/" "static types"], you can have them. But they are not forced, and that does make it easier to backslide.

Racket reminds me of haskell 15 years ago. Then you had hackage and cabal, and maybe things were hard, but they were solvable, and help was available and active in an IRC. But the people who gravitated to haskell were very smart and ambitious, and many of them did not see academics as their frontier, but they wanted to build things that people used, and as as the needs and priorities of industry dominated their use cases, the language begin to show their influence. This seems to me, an outsider, as extremely valuable for anyone who wants to use haskell for a real world project, but to the disadvantage of the hobbyist. Tant pis. I would not ask the language development to cater to my use cases.

However, I appreciate that I can find another language where all the packages seem to be written by graduate students. If that means they are active for only a few years before the @hyperlink["https://github.com/ntoronto/drbayes" "packages lose a maintainer"] so be it. I prefer the vibrancy of graduate enthusiasms to the move-fast and break-things of the industrial mover and shakers. I have already benefited by being guided to @hyperlink["https://www.philosophie.uni-konstanz.de/ag-spohn/personen/prof-dr-wolfgang-spohn/papers/" "ranking theory"] by a @hyperlink["https://github.com/tjitze/ranked-programming/tree/48cbec099f04c6e49c519415be36b910c8aff790" "package"] in the racket database.

@subsection[#:style 'unnumbered]{The dream}

The dream is to think about how to express cognitive models with a single broad language that will make them concrete and comparable across domains. The language should obviously be math, and the language within the field of mathematics that is most suited to translating across domains is category theory. It also seems to work well in applied fields, and I think holds promise for computational cognitive modelling. Languages like @hyperlink["https://github.com/statebox/idris-ct" "Idris"], @hyperlink["https://hackage.haskell.org/package/data-category" "Haskell"], and even @hyperlink["https://algebraicjulia.github.io/Catlab.jl/dev/" "Julia"] have libraries and packages for category theory, and even though one does not exist for racket there are @hyperlink["https://docs.racket-lang.org/lathe-morphisms/index.html" "some early efforts"]. Maybe racket can be the language the connects mathematical structures like the lambda calculus and category theory to computational models of psychology and neuroscience. 