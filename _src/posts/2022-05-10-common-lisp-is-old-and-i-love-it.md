    Date: 2022-05-10T10:54:28
    Title: Common Lisp Is Old. And I Love It
    Tags: common-lisp, programming-languages


Learning the basics of a programming language once is fun. Learning it every six months is tedious. One of the beautiful experiences of working with Common Lisp is that your learning is one and done. 

<!-- more -->

I started experimenting with Haskell around GHC 6.8. Hackage was still the go to then, but soon I ran into cabal hell, and I worried alot about my package index. Cabal Sandboxes appeared. And Stackage. And then there were new features of cabal-install that became declarative and then became defaults. I started using ArchLinux in the days when some key Haskellers made that their go to distribution. Then a change in static and dynamic linking brought the whole thing down upon my head. And finally I had to try and play with Nix to make things work. Pile on the number of language pragmas I had to worry about and it became too painful to continue. As someone who is not a programming language researcher or developer, gaps of two to three months without using Haskell were common (often longer). This always meant starting over. First, repair my broken system. Second, learn a new set of tools. 

This is not a rant about Haskell. I could have talked about Python2 to Python 3 and all the setup and installation tools recommended along the way (what happened to Wheels now that I think about it)? In fact, Haskell has been the single most transformative language I have worked with. It has helped me to develop practical skills, but more importantly to deepen my thinking about the use of programming languages for exploratory work in cognitive modelling. Work where the emphasis in not merely on efficiency or getting things done, but on looking to the language to facilitate one's own insights into the topic under investigation, and to explore languages themselves for evidence of patterns of thought that may reveal mechanisms of our internal symbol systems. 

And Lisps are no exception to this rapid evolution and the need for constant education on tooling and practice. Racket changes its back end compiler and now may even be making a fundamental move to a new syntax. Guile Scheme is hardly a static target.

But not so with Common Lisp. I read text books from 20 years ago, cut and paste code snippets, and it all just works. I stopped worrying about github repos with no commits for years. They are likely just done. I may still forget a lot about Common Lisp in my gaps between usage. And I may be frustrated by limits or libraries that don't give me exactly what I want without work, but by and large, when it comes time to re-learn that which I knew three months before the process is easier, because I am simply re-learning what I knew before. And each time it is easier, not harder, and each each time the retention lives longer. And I have yet to come across any application I, a non-industrial type, would want to code that I cannot do cleanly and relatively painlessly in Common Lisp. 

There are many other reasons to learn Common Lisp, but for me reason number one is that you won't have to learn it more than once. 
